---
title: "Untitled"
author: "Davd"
date: "2026-02-17"
output: html_document
---

```{r}
library(readxl)
library(dplyr)
library(lubridate)
library(janitor)

# 1) Read + clean names
df <- read_excel("Meters Data 2024.xlsx",
                 sheet = "Emerald Pickups",
                 range = "A1:P50074") %>%
  clean_names()

# 2) Convert month name + quarter text, create date + factors
df <- df %>%
  mutate(
    year = as.integer(date_year),

    # month name ("November") -> 11
    month_num = match(trimws(date_month), month.name),

    # "Qtr 4" -> 4
    quarter_num = as.integer(gsub("[^0-9]", "", date_quarter)),

    # year-month date (first of month)
    ym = make_date(year, month_num, 1),

    # factors for modeling (MONTH AS NON-ORDERED FACTOR)
    month = factor(trimws(date_month), levels = month.name, ordered = FALSE),
    quarter = factor(quarter_num, levels = 1:4)
  )

# 3) Quick checks
stopifnot(!anyNA(df$ym))
table(df$month, useNA = "ifany")
table(df$quarter, useNA = "ifany")

name_lookup <- df %>%
  mutate(customer_name_clean = trimws(customer_name)) %>%
  group_by(customer_id, customer_name_clean) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(customer_id) %>%
  slice_max(n, with_ties = FALSE) %>%
  transmute(customer_id, customer_name = customer_name_clean)

# attach canonical name back onto your data
df2 <- df %>%
  select(-customer_name) %>%
  left_join(name_lookup, by = "customer_id")

stopifnot(!anyNA(df2$month_num))

df_monthly <- df2 %>%
  group_by(customer_id, ym, year, month, quarter) %>%
  summarise(
    customer_name = first(customer_name),   # carry name along, don't group by it
    pickups = sum(pickups, na.rm = TRUE),
    .groups = "drop"
  )




```



```{r}
get_pickups <- function(data, customer_id_value, year_value, month_value) {
  
  # standardize month input
  month_value <- tools::toTitleCase(tolower(month_value))
  
  result <- data %>%
    filter(
      customer_id == customer_id_value,
      year == year_value,
      as.character(month) == month_value
    )
  
  if (nrow(result) == 0) {
    return(paste(
      "No pickups for customer",
      customer_id_value,
      "in",
      month_value,
      year_value
    ))
  }
  
  total <- sum(result$pickups, na.rm = TRUE)
  
  return(paste(
    "Customer",
    customer_id_value,
    "had",
    total,
    "pickups in",
    month_value,
    year_value
  ))
}


```


```{r}
get_pickups(df_monthly, 'ALA00330', 2024, "November")

```

```{r}
library(readxl)
library(dplyr)
library(janitor)

meters <- read_excel("Meters Data 2024.xlsx", sheet = "Combined Meter Data") %>%
  clean_names()

meters_one <- meters %>%
  transmute(
    customer_id = trimws(as.character(emerald_customer_id)),
    data_year = suppressWarnings(as.integer(data_year)),
    ownership,
    ba_code,
    residential,
    commercial,
    industrial,
    transportation,
    total_meters,
    meter_state = emerald_customer_state
  ) %>%
  arrange(customer_id, desc(data_year), desc(total_meters)) %>%
  distinct(customer_id, .keep_all = TRUE)

df_monthly2 <- df_monthly %>%
  mutate(customer_id = trimws(as.character(customer_id)))

df_model_all <- df_monthly2 %>%
  left_join(meters_one, by = "customer_id", relationship = "many-to-one") %>%
  mutate(has_meter_data = !is.na(total_meters))

df_model <- df_model_all %>% filter(has_meter_data)

mean(is.na(df_model_all$total_meters))


```


```{r}
collapse_rare_global <- function(x, min_count = 25) {
  x <- as.character(x)
  freq <- table(x)

  rare_levels <- names(freq[freq < min_count])

  x[x %in% rare_levels] <- "OTHER"

  factor(x)
}

df_model <- df_model %>%
  mutate(
    ba_code = collapse_rare_global(ba_code, min_count = 25),
    ownership = collapse_rare_global(ownership, min_count = 15)
  )

df_all <- df_model %>%
  mutate(
    customer_id = trimws(as.character(customer_id)),
    month = factor(as.character(month), levels = month.name),
    year = factor(year)   # year now has variation â€” safe to include
  )
set.seed(123)


train <- df_all %>%
  group_by(ba_code) %>%
  slice_sample(prop = 0.7) %>%
  ungroup()

test <- anti_join(df_all, train,
                  by = c("customer_id", "ym", "pickups"))




```


```{r}
# Fit (after recoding)
model_full <- lm(
  pickups ~  month +
    residential + commercial + industrial +
    transportation + ownership + ba_code,
  data = train
)
summary(model_full)

# Predict using the same recoded test
test$pred <- predict(model_full, newdata = test)

rmse <- sqrt(mean((test$pickups - test$pred)^2))
mae  <- mean(abs(test$pickups - test$pred))

rmse
mae



```






```{r}
library(readxl)
library(dplyr)
library(lubridate)
library(janitor)

# -----------------------------
# 1) READ PICKUPS + CLEAN
# -----------------------------
df <- read_excel(
  "Meters Data 2024.xlsx",
  sheet = "Emerald Pickups",
  range = "A1:P50074"
) %>%
  clean_names()


```

```{r}
# -----------------------------
# 2) PARSE TIME FIELDS
# -----------------------------
df <- df %>%
  mutate(
    year = as.integer(date_year),

    # month name ("November") -> 11
    month_num = match(trimws(date_month), month.name),

    # "Qtr 4" -> 4
    quarter_num = as.integer(gsub("[^0-9]", "", date_quarter)),

    # year-month date (first of month)
    ym = make_date(year, month_num, 1),

    # factors for modeling (MONTH AS NON-ORDERED FACTOR)
    month = factor(trimws(date_month), levels = month.name, ordered = FALSE),
    quarter = factor(quarter_num, levels = 1:4)
  )

# Quick checks
stopifnot(!anyNA(df$ym))
table(df$month, useNA = "ifany")
table(df$quarter, useNA = "ifany")

```

```{r}
# -----------------------------
# 3) CANONICAL CUSTOMER NAME (MOST COMMON PER ID)
# -----------------------------
name_lookup <- df %>%
  mutate(customer_name_clean = trimws(customer_name)) %>%
  group_by(customer_id, customer_name_clean) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(customer_id) %>%
  slice_max(n, with_ties = FALSE) %>%
  transmute(customer_id, customer_name = customer_name_clean)

df2 <- df %>%
  select(-customer_name) %>%
  left_join(name_lookup, by = "customer_id")

stopifnot(!anyNA(df2$month_num))
```

```{r}
# -----------------------------
# 4) MONTHLY AGGREGATION
# -----------------------------
df_monthly <- df2 %>%
  group_by(customer_id, ym, year, month, quarter) %>%
  summarise(
    customer_name = first(customer_name),
    pickups = sum(pickups, na.rm = TRUE),
    .groups = "drop"
  )

```

```{r}
# -----------------------------
# 5) HELPER: GET PICKUPS
# -----------------------------
get_pickups <- function(data, customer_id_value, year_value, month_value) {
  month_value <- tools::toTitleCase(tolower(month_value))

  result <- data %>%
    filter(
      customer_id == customer_id_value,
      year == year_value,
      as.character(month) == month_value
    )

  if (nrow(result) == 0) {
    return(paste(
      "No pickups for customer",
      customer_id_value,
      "in",
      month_value,
      year_value
    ))
  }

  total <- sum(result$pickups, na.rm = TRUE)

  paste(
    "Customer",
    customer_id_value,
    "had",
    total,
    "pickups in",
    month_value,
    year_value
  )
}

# Example
get_pickups(df_monthly, "ALA00330", 2024, "November")
```

```{r}
# -----------------------------
# 6) READ METERS + KEEP 1 ROW PER CUSTOMER
# -----------------------------
meters <- read_excel("Meters Data 2024.xlsx", sheet = "Combined Meter Data") %>%
  clean_names()

meters_one <- meters %>%
  transmute(
    customer_id   = trimws(as.character(emerald_customer_id)),
    data_year     = suppressWarnings(as.integer(data_year)),
    ownership,
    ba_code,
    residential,
    commercial,
    industrial,
    transportation,
    total_meters,
    meter_state = emerald_customer_state
  ) %>%
  arrange(customer_id, desc(data_year), desc(total_meters)) %>%
  distinct(customer_id, .keep_all = TRUE)
```



```{r}
# -----------------------------
# 7) JOIN MONTHLY + METERS, ADD NUMERIC YEAR
# -----------------------------
df_monthly2 <- df_monthly %>%
  mutate(customer_id = trimws(as.character(customer_id)))

df_model_all <- df_monthly2 %>%
  left_join(meters_one, by = "customer_id", relationship = "many-to-one") %>%
  mutate(
    has_meter_data = !is.na(total_meters),

    # <-- THIS is the numeric year feature for forecasting
    # Use the monthly record year (NOT the meter snapshot year)
    year_num = as.integer(year)
  )

df_model <- df_model_all %>% filter(has_meter_data)

# how many monthly rows don't match to meters?
mean(is.na(df_model_all$total_meters))




```

```{r}

# -----------------------------
# 8) COLLAPSE RARE LEVELS (TO AVOID NEW-LEVEL ERRORS)
# -----------------------------
collapse_rare_global <- function(x, min_count = 25) {
  x <- as.character(x)
  freq <- table(x)
  rare_levels <- names(freq[freq < min_count])
  x[x %in% rare_levels] <- "OTHER"
  factor(x)
}

df_all <- df_model %>%
  mutate(
    ba_code    = collapse_rare_global(ba_code, min_count = 25),
    ownership  = collapse_rare_global(ownership, min_count = 15),

    # keep month as factor with fixed levels
    month = factor(as.character(month), levels = month.name),

    # IMPORTANT: keep year as numeric for extrapolation
    year_num = as.integer(year_num)
  )


```

```{r}

# -----------------------------
# 9) TRAIN / TEST SPLIT (STRATIFY BY BA)
# 
set.seed(123)

train <- df_all %>%
  group_by(ba_code) %>%
  slice_sample(prop = 0.7) %>%
  ungroup()

test <- anti_join(df_all, train, by = c("customer_id", "ym", "pickups"))

# Align factor levels (prevents "new levels" errors)
test$ba_code   <- factor(test$ba_code, levels = levels(train$ba_code))
test$ownership <- factor(test$ownership, levels = levels(train$ownership))
test$month     <- factor(test$month, levels = levels(train$month))

```

```{r}

# -----------------------------
# 10) FIT + PREDICT (WITH NUMERIC YEAR)
# -----------------------------
model_full <- lm(
  pickups ~ year_num + month +
    residential + commercial + industrial +
    transportation + ownership + ba_code,
  data = train
)

summary(model_full)

test$pred <- predict(model_full, newdata = test)

rmse <- sqrt(mean((test$pickups - test$pred)^2))
mae  <- mean(abs(test$pickups - test$pred))

rmse
mae

```


```



